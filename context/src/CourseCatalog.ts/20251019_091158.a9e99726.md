---
timestamp: 'Sun Oct 19 2025 09:11:58 GMT-0400 (Eastern Daylight Time)'
content_id: a9e9972645492de6534576356183abbcf5d687ab566b0ec8bb70b39d1fbd6b9a
---

# file: src/CourseCatalog.ts

```typescript
// states

/**
 * fetching data
 *
 * const rows = await db.collection("courses").find({}).toArray();
    const catalog = CourseCatalog.fromDbRows(rows);
 *
 */

export interface Requirement {
  code: string; // e.g., "QR", "HSCI", "LAB", "WRI"
  name?: string; // Human-readable label
}

export interface TimeSlot {
  // Example: { day: "Mon", start: "10:00", end: "11:20", tz: "America/New_York" }
  day: "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun";
  start: string; // "HH:MM" 24h
  end: string; // "HH:MM" 24h
  tz?: string;
}

export interface Course {
  courseId: string; // authoritative ID, e.g., "CS-220-01-FA25"
  title: string; // "Blue on the Move"
  instructor: string; // "Ada Lovelace"
  meetingTimes: TimeSlot[];
  location?: string; // "SCI 101" or "Zoom"
  requirements: Requirement[];
  campus: string; // "Wellesley", "MIT", etc.
}

export type CourseFilters = {
  instructor?: string; // fuzzy match (case-insensitive)
  requirementCode?: string; // e.g., "QR"
  department?: string; // e.g., "CS", "MATH" (derived from leading letters of courseId)
  day?: TimeSlot["day"]; // "Mon" | ... | "Sun"
  timeWindow?: {
    start: string; // "HH:MM" 24h
    end: string; // "HH:MM" 24h
  };
};

// === DB adapter for Mongo documents =======================================

// Matches your actual Mongo shape
type CourseDB = {
  _id?: unknown;
  courseID: string; // capital D in DB
  title: string;
  instructor: string;
  meetingTimes: Array<
    | { day: string; start: string; end: string; tz?: string }
    | string
  >;
  requirements?: Requirement[]; // "CS111 || CS111M || ..."
  campus?: string; // optional in DB
};

const DEFAULT_CAMPUS = "Wellesley";

// Convert DB row â†’ app Course
function adaptCourse(dbRow: CourseDB): Course {
  const meetingTimes: TimeSlot[] = (dbRow.meetingTimes ?? [])
    .map(normalizeTimeSlotLoose)
    .filter((t): t is TimeSlot => t !== null);

  const requirements = dbRow.requirements ?? [];

  return {
    courseId: dbRow.courseID,
    title: dbRow.title,
    instructor: dbRow.instructor,
    meetingTimes,
    requirements,
    campus: dbRow.campus ?? DEFAULT_CAMPUS,
  };
}

// Helper: allow "Mon 10:00-11:20" or object form
function normalizeTimeSlotLoose(raw: any): TimeSlot | null {
  if (typeof raw === "string") {
    const m = raw.match(
      /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+(\d{2}:\d{2})-(\d{2}:\d{2})$/,
    );
    if (!m) return null;
    return { day: m[1] as TimeSlot["day"], start: m[2], end: m[3] };
  }
  if (!raw || !raw.day || !raw.start || !raw.end) return null;
  const valid = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"].includes(
    raw.day,
  );
  if (!valid) return null;
  return {
    day: raw.day as TimeSlot["day"],
    start: String(raw.start),
    end: String(raw.end),
    tz: raw.tz,
  };
}

//getdeparmtnet helper for database integration
function departmentOfCourseId(courseId: string): string {
  // Grab the leading run of letters (ignore hyphens/spaces/numbers that follow)
  // Examples:
  //   "CS230"        -> "CS"
  //   "MATH-220-01"  -> "MATH"
  //   "BIOE101"      -> "BIOE"
  //   "EECS-6.006"   -> "EECS"
  const m = (courseId || "").trim().match(/^[A-Za-z]+/);
  return (m?.[0] ?? "").toUpperCase();
}

// Convenience: transform many DB rows
function adaptMany(rows: CourseDB[]): Course[] {
  return rows.map(adaptCourse);
}

/**
 * === CourseCatalog ===========================================================
 * purpose:
 *   provide authoritative course data (times, locations, instructors, requirements)
 *   for search and planning
 *
 * principle:
 *   the catalog aggregates courses each term; students query it for information,
 *   and other concepts (Schedule, RequirementTracker, CrossRegTravel) rely on it
 *   for consistency
 *
 * state:
 *   a set of Courses keyed by courseId
 *
 * actions:
 *   - search(query, filters) -> Set<Course>
 *   - getById(courseId) -> Course
 *   - listByRequirement(req) -> Set<Course>
 */
export class CourseCatalog {
  /**
   * === State: the authoritative set of Courses ===============================
   * Internally we keep both:
   *  - a Map keyed by courseId for fast lookups
   *  - an array snapshot for simple scans (search/filter)
   * You can later swap the backing store for a DB without changing method signatures.
   */
  private byId: Map<string, Course> = new Map();
  private all: Course[] = [];

  static fromDbRows(rows: any[]): CourseCatalog {
    return new CourseCatalog(adaptMany(rows as CourseDB[]));
  }

  constructor(initialCourses: Course[] = []) {
    this.load(initialCourses);
  }

  /**
   * Load/replace the catalog content for the current term.
   * (Not part of the original actions, but useful for bootstrapping/tests.)
   */
  load(courses: Course[]): void {
    this.byId.clear();
    this.all = [];
    for (const c of courses) {
      this.byId.set(c.courseId, c);
      this.all.push(c);
    }
  }

  /**
   * === Action: getById(courseId) -> Course ===================================
   * requires: a course with this courseId exists
   * effects:  returns that course
   *
   * Throws a descriptive error if not found (so callers can handle it explicitly).
   */
  getById(courseId: string): Course {
    const found = this.byId.get(courseId);
    if (!found) {
      throw new Error(
        `CourseCatalog.getById: courseId "${courseId}" not found`,
      );
    }
    return found;
  }

  /**
   * === Action: listByRequirement(req) -> Set<Course> ==========================
   * effects: return all courses that satisfy req
   *
   * Matching rule: any course whose `requirements` contains a Requirement
   * with the same `code` (case-insensitive) is included.
   */
  listByRequirement(req: Requirement): Set<Course> {
    const code = req.code.toLowerCase();
    const results = new Set<Course>();
    for (const c of this.all) {
      if (c.requirements?.some((r) => r.code.toLowerCase() === code)) {
        results.add(c);
      }
    }
    return results;
  }

  /**
   * === Action: search(query, filters) -> Set<Course> ==========================
   * effects: return all courses matching the given query/filters
   *
   * Query behavior (case-insensitive):
   *  - If empty/undefined: rely only on filters.
   *  - If provided: match if ANY of the tokens appears in
   *      courseId, title, or instructor.
   *
   * Filters:
   *  - instructor: fuzzy contains
   *  - campus: fuzzy contains
   *  - requirementCode: course must include this req code
   *  - day: at least one meetingTime has this day
   *  - timeWindow: keep courses that overlap the window on ANY day
   *                (overlap rule: start < window.end AND end > window.start)
   */
  search(query?: string, filters: CourseFilters = {}): Set<Course> {
    const tokens = tokenize(query);

    const results = new Set<Course>();
    for (const c of this.all) {
      // Token match (if tokens exist)
      const hay = `${c.courseId} ${c.title} ${c.instructor}`.toLowerCase();
      const tokenOk = tokens.length === 0 ||
        tokens.some((t) => hay.includes(t));

      if (!tokenOk) continue;

      // Filter: instructor
      if (
        filters.instructor && !fuzzyContains(c.instructor, filters.instructor)
      ) continue;

      // Filter: campus
      if (filters.campus && !fuzzyContains(c.campus, filters.campus)) continue;

      // Filter: requirementCode
      if (filters.requirementCode) {
        const code = filters.requirementCode.toLowerCase();
        const hasReq = c.requirements?.some((r) =>
          r.code.toLowerCase() === code
        );
        if (!hasReq) continue;
      }

      // Filter: day
      if (filters.day) {
        const meetsThatDay = c.meetingTimes?.some((mt) =>
          mt.day === filters.day
        );
        if (!meetsThatDay) continue;
      }

      // Filter: timeWindow (overlap anywhere)
      if (filters.timeWindow) {
        const { start, end } = filters.timeWindow;
        const win = { start: toMinutes(start), end: toMinutes(end) };
        const overlaps = c.meetingTimes?.some((mt) => {
          const a = toMinutes(mt.start);
          const b = toMinutes(mt.end);
          return intervalsOverlap(a, b, win.start, win.end);
        });
        if (!overlaps) continue;
      }

      results.add(c);
    }
    return results;
  }
}

/**
 * === Helpers =================================================================
 */

function tokenize(q?: string): string[] {
  return (q ?? "")
    .trim()
    .toLowerCase()
    .split(/\s+/)
    .filter(Boolean);
}

function fuzzyContains(haystack: string, needle: string): boolean {
  return haystack.toLowerCase().includes(needle.toLowerCase());
}

function toMinutes(hhmm: string): number {
  // naive parser: "HH:MM" -> minutes since 00:00
  const [h, m] = hhmm.split(":").map(Number);
  return h * 60 + m;
}

function intervalsOverlap(
  aStart: number,
  aEnd: number,
  bStart: number,
  bEnd: number,
): boolean {
  // Overlap if each starts before the other ends
  return aStart < bEnd && bStart < aEnd;
}

```
