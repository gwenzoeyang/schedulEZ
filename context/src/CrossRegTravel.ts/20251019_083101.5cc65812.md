---
timestamp: 'Sun Oct 19 2025 08:31:01 GMT-0400 (Eastern Daylight Time)'
content_id: 5cc65812f209e2528e8dad02c9aae7698f756a1cfdad9f959b529c2ac9b40b4e
---

# file: src/CrossRegTravel.ts

```typescript
export type Day = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun";

export interface TimeSlot {
  day: Day;
  start: string; // "HH:MM" 24h
  end: string; // "HH:MM" 24h
  tz?: string;
}

export interface Requirement {
  code: string;
  name?: string;
}

export interface Course {
  courseId: string;
  title: string;
  instructor: string;
  meetingTimes: TimeSlot[];
  location: string; // e.g., "SCI 101"
  requirements: Requirement[];
  campus: string; // e.g., "Wellesley", "MIT"
}

export interface TravelViolation {
  code: string;
  message: string;
  details?: unknown;
}

/**
 * === Travel rule model (your state) ==========================================
 * For each campus pair, we keep:
 *  - minBufferMinutes: baseline walk/transition buffer (in/out-of-building, etc.)
 *  - transitTimetable: a list of trips with specific depart/arrive times (minutes since 00:00)
 *    Optionally restrict trips to certain days (if omitted, we assume all days).
 */
export interface RouteTrip {
  departMin: number; // departure time (minutes since 00:00 local)
  arriveMin: number; // arrival time (minutes since 00:00 local)
  days?: Day[]; // if provided, this trip runs only on these days
}

export interface TravelRule {
  originCampus: string;
  destCampus: string;
  minBufferMinutes: number; // walking + changeover baseline
  transitTimetable: RouteTrip[];
}

/**
 * === CrossRegTravel concept ==================================================
 * purpose:
 *   ensure that courses across campuses have feasible travel gaps
 *
 * principle:
 *   travel feasibility is based on shuttle timetables, walking buffers, and minimum gaps;
 *   invalid pairs must be flagged
 *
 * state:
 *   a set of TravelRules with
 *     - originCampus, destCampus
 *     - minBufferMinutes
 *     - transitTimetable (Set of RouteTrip {depart, arrive})
 *
 * actions:
 *   - estimate(a, b) -> minutes
 *   - violations(courses) -> Set<(Course, Course)>
 */
export class CrossRegTravel {
  /**
   * We index rules by "origin||dest" (lowercased) for quick lookup.
   */
  private rules: Map<string, TravelRule> = new Map();

  constructor(initialRules: TravelRule[] = []) {
    this.load(initialRules);
  }

  /** Replace all rules (e.g., when a new term’s shuttle schedule is published). */
  load(rules: TravelRule[]): void {
    this.rules.clear();
    for (const r of rules) {
      this.rules.set(keyPair(r.originCampus, r.destCampus), normalizeRule(r));
    }
  }

  /**
   * === Action: estimate(a, b) -> minutes =====================================
   * requires:
   *   - a.meetingTimes end before b.meetingTimes start (for the chosen day pair)
   * effects:
   *   - return the shortest feasible travel time between a.location and b.location
   *     using timetable + buffer
   *
   * Notes:
   * - For same-campus moves, we return the configured buffer for (campus -> campus) if present,
   *   otherwise a default fallback (e.g., 10 minutes).
   * - For cross-campus, we find the **earliest trip** on that day that departs at or after
   *   (endOfA + minBuffer) and compute travel_minutes = (arrival - endOfA) + minBuffer.
   *   If no trip fits before b.start, we return Infinity.
   */
  estimate(a: Course, b: Course): number {
    let best = Number.POSITIVE_INFINITY;

    for (const ta of a.meetingTimes ?? []) {
      for (const tb of b.meetingTimes ?? []) {
        if (ta.day !== tb.day) continue; // only compare same-day transitions
        const endA = toMinutes(ta.end);
        const startB = toMinutes(tb.start);
        if (!(endA < startB)) continue; // requires end(A) before start(B)

        if (a.campus.toLowerCase() === b.campus.toLowerCase()) {
          // Same-campus move: use a same-campus rule if defined; else fallback
          const rr = this.rules.get(keyPair(a.campus, b.campus));
          const minBuf = rr?.minBufferMinutes ?? DEFAULT_SAME_CAMPUS_BUFFER_MIN;
          const travel = minBuf; // baseline walking/transition on same campus
          if (travel < best) best = travel;
          continue;
        }

        // Cross-campus: consult timetable for (A -> B)
        const rule = this.rules.get(keyPair(a.campus, b.campus));
        if (!rule) continue; // No route defined; infeasible -> Infinity

        const minBuf = rule.minBufferMinutes;
        const readyToDepart = endA + minBuf;
        const windowEnd = startB; // must arrive by startB to be feasible

        // find earliest trip that runs today and departs >= readyToDepart and arrives <= windowEnd
        for (const trip of rule.transitTimetable) {
          if (trip.days && !trip.days.includes(ta.day)) continue;
          if (trip.departMin < readyToDepart) continue;
          if (trip.arriveMin > windowEnd) continue;

          // total “gap needed” measured from endA to “ready-in-seat for B”
          const travelGap = (trip.arriveMin - endA) + minBuf;
          if (travelGap < best) best = travelGap;
        }
      }
    }

    return best;
  }

  public violations(
    owner: { id: string },
    courses: Course[],
  ): TravelViolation[] {
    // owner isn’t needed for computation right now, but we accept it to match the interface
    const pairs = this._violationsSet(new Set(courses));
    const out: TravelViolation[] = [];
    for (const [a, b] of pairs) {
      out.push({
        code: "CROSS_CAMPUS_GAP",
        message:
          `Insufficient travel time between "${a.courseId}" → "${b.courseId}"`,
        details: {
          from: a.courseId,
          to: b.courseId,
          fromCampus: a.campus,
          toCampus: b.campus,
        },
      });
    }
    return out;
  }

  /**
   * === Action: violations(courses) -> Set<(Course, Course)> ===================
   * effects:
   *   return all **adjacent** cross-campus course pairs where
   *   (gap between end of one and start of the other) < estimated travel time
   *
   * "Adjacent" means: on the same day, one ends before the other starts, and
   * there is no other course whose time window lies strictly between them
   * (on that day).
   */
  private _violationsSet(courses: Set<Course>): Set<[Course, Course]> {
    const out = new Set<[Course, Course]>();
    const byDay = explodeByDaySorted(courses);

    for (const day of Object.keys(byDay) as Day[]) {
      const blocks = byDay[day]; // [{ course, startMin, endMin, campus }]
      // Walk adjacent blocks only
      for (let i = 0; i < blocks.length - 1; i++) {
        const A = blocks[i];
        const B = blocks[i + 1];
        if (!(A.endMin < B.startMin)) continue; // must be strictly before

        // Only consider cross-campus (spec says "cross-campus course pairs")
        if (A.campus.toLowerCase() === B.campus.toLowerCase()) continue;

        const est = this.estimate(A.course, B.course); // checks all timeslots (including this day)
        const actualGap = B.startMin - A.endMin;

        if (actualGap < est) {
          out.add([A.course, B.course]);
        }
      }
    }

    return out;
  }
}

/** ============================== Helpers ================================== */

const DEFAULT_SAME_CAMPUS_BUFFER_MIN = 10;

function keyPair(originCampus: string, destCampus: string): string {
  return `${originCampus}||${destCampus}`.toLowerCase();
}

function toMinutes(hhmm: string): number {
  const [h, m] = hhmm.split(":").map(Number);
  return h * 60 + m;
}

function normalizeRule(r: TravelRule): TravelRule {
  // Ensure trips are sorted by depart and valid (depart <= arrive)
  const trips = [...(r.transitTimetable ?? [])]
    .filter((t) =>
      isFinite(t.departMin) && isFinite(t.arriveMin) &&
      t.departMin <= t.arriveMin
    )
    .sort((a, b) => a.departMin - b.departMin);

  return {
    originCampus: r.originCampus,
    destCampus: r.destCampus,
    minBufferMinutes: Math.max(0, Math.floor(r.minBufferMinutes ?? 0)),
    transitTimetable: trips,
  };
}

/**
 * Take a set of courses and explode their meeting times into day-sorted blocks:
 *  byDay[day] = [{ course, startMin, endMin, campus }]
 * Then sort by startMin (tie-break by endMin).
 */
function explodeByDaySorted(
  courses: Set<Course>,
): Record<
  Day,
  Array<{ course: Course; startMin: number; endMin: number; campus: string }>
> {
  const byDay: Record<
    Day,
    Array<{ course: Course; startMin: number; endMin: number; campus: string }>
  > = {
    Mon: [],
    Tue: [],
    Wed: [],
    Thu: [],
    Fri: [],
    Sat: [],
    Sun: [],
  };

  for (const c of courses) {
    for (const t of c.meetingTimes ?? []) {
      byDay[t.day].push({
        course: c,
        startMin: toMinutes(t.start),
        endMin: toMinutes(t.end),
        campus: c.campus,
      });
    }
  }

  for (const d of Object.keys(byDay) as Day[]) {
    byDay[d].sort((a, b) => (a.startMin - b.startMin) || (a.endMin - b.endMin));
  }

  return byDay;
}

```
