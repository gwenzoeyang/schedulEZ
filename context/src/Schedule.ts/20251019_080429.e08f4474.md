---
timestamp: 'Sun Oct 19 2025 08:04:29 GMT-0400 (Eastern Daylight Time)'
content_id: e08f4474e40f030bc7d1f3de1d7e828e43b08dc21e2db49c4f9f365fba5e4ae5
---

# file: src/Schedule.ts

```typescript
export interface User {
  id: string;
  name?: string;
}

export type Day = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun";

export interface TimeSlot {
  day: Day;
  start: string; // "HH:MM" 24h
  end: string; // "HH:MM" 24h
  tz?: string;
}

export interface Requirement {
  code: string;
  name?: string;
}

export interface Course {
  courseId: string;
  title: string;
  instructor: string;
  meetingTimes: TimeSlot[];
  location: string;
  requirements: Requirement[];
  campus: string;
}

/**
 * === External dependencies (assumed implemented elsewhere) ===================
 */
export interface CourseCatalogLike {
  getById(courseId: string): Course; // throws if not found
  search(query?: string, filters?: unknown): Set<Course>; // used broadly to get candidates
}

export interface TravelViolation {
  code: string;
  message: string;
  details?: unknown;
}

export interface CrossRegTravelLike {
  violations(owner: User, courses: Course[]): TravelViolation[];
}

/** Simple AI chooser that picks ONE course from filtered candidates. */
export interface AIRecommenderLike {
  chooseCourse(
    owner: User,
    candidates: Course[],
    prefs: AIPreferences,
  ): Promise<Course | null> | Course | null;
}

/**
 * === New AI state container ===================================================
 */
export interface AIPreferences {
  major: string;
  interests: Set<string>;
  availability: Set<TimeSlot>;
}

/**
 * === External dependencies (assumed implemented elsewhere) ===================
 * - CourseCatalog: used only to verify a courseId exists when adding by object.
 * - CrossRegTravel: computes travel/time feasibility; no violations => OK.
 */
export interface CourseCatalogLike {
  getById(courseId: string): Course; // throws if not found
}

export interface TravelViolation {
  code: string;
  message: string;
  details?: unknown;
}

export interface CrossRegTravelLike {
  /**
   * Return any violations for the proposed schedule.
   * If empty, schedule is feasible from a travel-gap standpoint.
   */
  violations(owner: User, courses: Course[]): TravelViolation[];
}

/**
 * === Schedule concept ========================================================
 * purpose:
 *   let a student compose a tentative plan while preventing time conflicts
 *
 * principle:
 *   each schedule belongs to one student; adding a course must check for
 *   overlapping times and infeasible travel gaps
 *
 * state:
 *   a set of Schedules:
 *     - owner: User
 *     - courses: Set<Course>
 *
 * actions:
 *   - addCourse(owner, course)
 *   - removeCourse(owner, courseId)
 *   - listSchedule(owner) -> Set<Course>
 *   - clear(owner)
 */
export class Schedule {
  /**
   * === State storage =========================================================
   * Map userId -> Map<courseId, Course> for O(1) lookups and de-dup.
   */
  private schedules: Map<string, Map<string, Course>> = new Map();

  constructor(
    private readonly catalog: CourseCatalogLike,
    private readonly travel: CrossRegTravelLike,
  ) {}

  /**
   * Ensure a user has an initialized (possibly empty) schedule entry.
   */
  private ensureSchedule(owner: User): Map<string, Course> {
    let m = this.schedules.get(owner.id);
    if (!m) {
      m = new Map<string, Course>();
      this.schedules.set(owner.id, m);
    }
    return m;
  }

  /**
   * === Action: addCourse(owner, course) ======================================
   * requires:
   *   - course exists in CourseCatalog
   *   - course.meetingTimes do not overlap with any courses already in owner's schedule
   *   - CrossRegTravel.violations(owner’s schedule ∪ {course}) = ∅
   * effects:
   *   - add course to owner's schedule
   */
  addCourse(owner: User, course: Course): void {
    // 1) Verify existence in CourseCatalog (authoritative source)
    //    Uses courseId; throws if not found.
    this.catalog.getById(course.courseId);

    const sched = this.ensureSchedule(owner);

    // 2) Prevent duplicates
    if (sched.has(course.courseId)) {
      throw new Error(
        `Schedule.addCourse: course "${course.courseId}" is already in the schedule`,
      );
    }

    // 3) Check time overlaps against existing courses
    for (const existing of sched.values()) {
      if (coursesOverlap(existing, course)) {
        throw new Error(
          `Schedule.addCourse: "${course.courseId}" overlaps with "${existing.courseId}"`,
        );
      }
    }

    // 4) Check cross-registration travel feasibility on the union schedule
    const union = [...sched.values(), course];
    const vios = this.travel.violations(owner, union);
    if (vios.length > 0) {
      const msg = vios.map((v) => v.message).join("; ");
      throw new Error(
        `Schedule.addCourse: travel/transition infeasible — ${msg}`,
      );
    }

    // 5) All good — add it
    sched.set(course.courseId, course);
  }

  /**
   * === Action: removeCourse(owner, courseId) =================================
   * requires:
   *   - owner's schedule contains a course with this id
   * effects:
   *   - remove that course from the schedule
   */
  removeCourse(owner: User, courseId: string): void {
    const sched = this.ensureSchedule(owner);
    if (!sched.has(courseId)) {
      throw new Error(
        `Schedule.removeCourse: course "${courseId}" not found in schedule`,
      );
    }
    sched.delete(courseId);
  }

  /**
   * === Action: listSchedule(owner) -> Set<Course> =============================
   * requires:
   *   - owner has at least one course in their schedule
   * effects:
   *   - return all courses in owner's schedule
   */
  listSchedule(owner: User): Set<Course> {
    const sched = this.ensureSchedule(owner);
    if (sched.size === 0) {
      throw new Error(`Schedule.listSchedule: schedule is empty`);
    }
    return new Set(sched.values());
  }

  /**
   * === Action: clear(owner) ==================================================
   * effects:
   *   - remove all courses from owner's schedule
   */
  clear(owner: User): void {
    const sched = this.ensureSchedule(owner);
    sched.clear();
  }
}

/**
 * === Overlap logic ===========================================================
 * Two courses overlap iff any pair of their TimeSlots overlap on the same day.
 * Edge-touching times (end == start) are considered NON-overlapping.
 */
function coursesOverlap(a: Course, b: Course): bool {
  for (const ta of a.meetingTimes ?? []) {
    for (const tb of b.meetingTimes ?? []) {
      if (ta.day !== tb.day) continue;
      if (
        intervalsOverlap(
          toMinutes(ta.start),
          toMinutes(ta.end),
          toMinutes(tb.start),
          toMinutes(tb.end),
        )
      ) {
        return true;
      }
    }
  }
  return false;
}

function toMinutes(hhmm: string): number {
  const [h, m] = hhmm.split(":").map(Number);
  return h * 60 + m;
}

function intervalsOverlap(
  aStart: number,
  aEnd: number,
  bStart: number,
  bEnd: number,
): boolean {
  return aStart < bEnd && bStart < aEnd; // edge-touching is OK
}

```
