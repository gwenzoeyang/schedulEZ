---
timestamp: 'Sun Oct 19 2025 14:23:30 GMT-0400 (Eastern Daylight Time)'
content_id: 9fbd629ddeaea99b70fb754d9830a4d4606077d463b81617036530e61449694a
---

# file: src/Schedule.ts

```typescript
// src/concepts/Schedule.ts

import { type Course, CourseCatalog, type TimeSlot } from "./CourseCatalog.ts";

export interface User {
  id: string;
  name?: string;
}

export interface CourseCatalogLike {
  getById(courseID: string): Course; // throws if not found
  search(query?: string, filters?: unknown): Set<Course>;
}

export interface AIRecommenderLike {
  chooseCourse(
    owner: User,
    candidates: Course[],
    prefs: AIPreferences,
  ): Promise<Course | null> | Course | null;
}

export interface AIPreferences {
  major: string;
  interests: Set<string>;
  availability: Set<TimeSlot>;
}

/* ---------------------- env helper ---------------------- */
async function loadEnv(name: string): Promise<string> {
  try {
    // deno-lint-ignore no-explicit-any
    const v = (globalThis as any).Deno?.env?.get?.(name);
    if (typeof v === "string" && v.length) return v;
  } catch {}
  try {
    // deno-lint-ignore no-explicit-any
    const v = (globalThis as any).process?.env?.[name];
    if (typeof v === "string" && v.length) return v;
  } catch {}
  return "";
}

/* ---------------- Gemini (unchanged) ---------------- */
type GenAIModel = {
  generateContent(prompt: string): Promise<{ response: { text(): string } }>;
};
type GenAIClient = {
  getGenerativeModel(
    args: { model: string; generationConfig?: unknown },
  ): GenAIModel;
};

let _GeminiCtor: (new (apiKey: string) => GenAIClient) | null = null;
let _geminiInitTried = false;

async function loadGeminiCtor(): Promise<void> {
  if (_geminiInitTried) return;
  _geminiInitTried = true;
  try {
    const mod = await import("@google/generative-ai");
    // deno-lint-ignore no-explicit-any
    _GeminiCtor = (mod as any).GoogleGenerativeAI ?? null;
  } catch {
    _GeminiCtor = null;
  }
}

// optional config like your prep
async function loadGeminiGenerationConfig(): Promise<unknown | undefined> {
  try {
    // @ts-ignore JSON import assertion (Deno friendly)
    const cfg = await import(
      "/Users/gwen-zoeyang/schedulEZ/geminiConfig.json",
      { with: { type: "json" } } as any
    );
    // deno-lint-ignore no-explicit-any
    return (cfg as any)?.default ?? (cfg as any);
  } catch {
    return undefined;
  }
}

async function chooseWithGemini(
  owner: User,
  candidates: Course[],
  prefs: AIPreferences,
): Promise<Course | null> {
  if (!candidates.length) return null;

  await loadGeminiCtor();
  const apiKey = await loadEnv("GEMINI_API_KEY");
  if (!_GeminiCtor || !apiKey) return null;

  const modelName = (await loadEnv("GEMINI_MODEL")) || "gemini-2.5-flash";
  const generationConfig = await loadGeminiGenerationConfig();

  const genAI = new _GeminiCtor(apiKey);
  const model = genAI.getGenerativeModel({
    model: modelName,
    generationConfig,
  });

  const slim = candidates.map((c) => ({
    courseID: c.courseID,
    title: c.title,
    instructor: c.instructor,
  }));
  const system =
    `Return ONLY a JSON object exactly like: {"courseID":"<exact id from the list>"}.
No commentary. If nothing fits, return {"courseID":""}.`;

  const prompt = `${system}\n` +
    `USER=${
      JSON.stringify({
        id: owner.id,
        major: prefs.major,
        interests: [...prefs.interests],
      })
    }\n` +
    `CANDIDATES=${JSON.stringify(slim)}`;

  const res = await model.generateContent(prompt);
  const text = res.response.text().trim().replace(/```json|```/g, "").trim();

  let picked = "";
  try {
    const obj = JSON.parse(text);
    picked = typeof obj?.courseID === "string" ? obj.courseID : "";
  } catch {
    const m = text.match(/"courseID"\\s*:\\s*"([^"]+)"/);
    picked = m?.[1] ?? "";
  }
  return picked
    ? (candidates.find((c) => c.courseID === picked) ?? null)
    : null;
}

/* -------- fetch candidates like LikertSurvey (via utils/database.ts) --------
   We DO NOT create or modify any other files.
   We dynamically import your existing DB helper and try its common APIs:
   - init()
   - collection(name)
   - getDb().collection(name)
   If none exist at runtime, we gracefully fall back to catalog.search().
----------------------------------------------------------------------------- */

async function fetchCoursesFromSharedDbOrFallback(
  fallbackCatalog: CourseCatalogLike,
): Promise<Course[]> {
  try {
    // dynamic import so we don't hard-bind to a specific API shape
    const dbmod = await import(
      "/Users/gwen-zoeyang/schedulEZ/src/utils/database.ts"
    );
    // 1) init if present
    if (typeof (dbmod as any).init === "function") {
      await (dbmod as any).init();
    }

    // pick collection name (default "courses", matching your code/tests)
    const collName = (await loadEnv("MONGODB_COLLECTION")) ||
      (await loadEnv("collection")) ||
      (await loadEnv("COLLECTION")) ||
      "courses";

    // 2) if a direct collection() helper exists, use it
    if (typeof (dbmod as any).collection === "function") {
      const rows = await (dbmod as any).collection(collName).find({}).toArray();
      const catalog = CourseCatalog.fromDbRows(rows as any);
      return [...(catalog.search() ?? new Set<Course>())];
    }

    // 3) else try getDb().collection(...)
    if (typeof (dbmod as any).getDb === "function") {
      const rows = await (dbmod as any).getDb().collection(collName).find({})
        .toArray();
      const catalog = CourseCatalog.fromDbRows(rows as any);
      return [...(catalog.search() ?? new Set<Course>())];
    }

    // 4) else try db or client properties if exposed
    // deno-lint-ignore no-explicit-any
    const maybeDb: any = (dbmod as any).db ?? (dbmod as any).database ?? null;
    if (maybeDb?.collection) {
      const rows = await maybeDb.collection(collName).find({}).toArray();
      const catalog = CourseCatalog.fromDbRows(rows as any);
      return [...(catalog.search() ?? new Set<Course>())];
    }
  } catch {
    // ignore and fall through to fallback
  }

  // fallback: use in-memory catalog
  return [...(fallbackCatalog.search() ?? new Set<Course>())];
}

/* ----------------------- Schedule (conflict-free) ----------------------- */

export class Schedule {
  private schedules: Map<
    string,
    {
      courses: Map<string, Course>;
      aiPreferences?: AIPreferences;
      aiSuggestion?: Course;
    }
  > = new Map();

  constructor(
    private readonly catalog: CourseCatalogLike,
    private readonly ai: AIRecommenderLike,
  ) {}

  addCourse(owner: User, course: Course): void {
    this.catalog.getById(course.courseID);
    const s = this.ensureState(owner);
    if (s.courses.has(course.courseID)) {
      throw new Error(
        `Schedule.addCourse: course "${course.courseID}" is already in the schedule`,
      );
    }
    s.courses.set(course.courseID, course);
  }

  removeCourse(owner: User, courseID: string): void {
    const s = this.ensureState(owner);
    if (!s.courses.has(courseID)) {
      throw new Error(
        `Schedule.removeCourse: course "${courseID}" not found in schedule`,
      );
    }
    s.courses.delete(courseID);
  }

  listSchedule(owner: User): Set<Course> {
    const s = this.ensureState(owner);
    if (s.courses.size === 0) {
      throw new Error(`Schedule.listSchedule: schedule is empty`);
    }
    return new Set(s.courses.values());
  }

  clear(owner: User): void {
    const s = this.ensureState(owner);
    s.courses.clear();
  }

  setAIPreferences(
    owner: User,
    major: string,
    interests: Set<string>,
    availability: Set<TimeSlot>,
  ): void {
    const s = this.ensureState(owner);
    s.aiPreferences = { major, interests, availability };
    s.aiSuggestion = undefined;
  }

  async suggestCourseAI(owner: User): Promise<Course> {
    const s = this.ensureState(owner);
    if (!s.aiPreferences) {
      throw new Error(
        `Schedule.suggestCourseAI: aiPreferences not set for this user`,
      );
    }

    // ðŸ”¹ fetch candidates via the same DB helper pattern your Likert code uses
    const all: Course[] = await fetchCoursesFromSharedDbOrFallback(
      this.catalog,
    );

    // Only exclude courses already in schedule
    const candidates = all.filter((c) => !s.courses.has(c.courseID));

    // 1) Gemini first
    let pick = await chooseWithGemini(owner, candidates, s.aiPreferences);

    // 2) Fallback to any adapter that may be passed in
    if (!pick && (this as any).ai?.chooseCourse) {
      pick = await (this as any).ai.chooseCourse(
        owner,
        candidates,
        s.aiPreferences,
      );
    }

    // 3) Last-resort to keep behavior stable
    if (!pick) pick = candidates[0] ?? null;

    if (!pick) {
      throw new Error(
        `Schedule.suggestCourseAI: no suitable course found by AI`,
      );
    }

    s.aiSuggestion = pick;
    return pick;
  }

  async updateAfterAddAI(owner: User, addedCourse: Course): Promise<Course> {
    const s = this.ensureState(owner);
    if (!s.aiPreferences) {
      throw new Error(
        `Schedule.updateAfterAddAI: aiPreferences not set for this user`,
      );
    }
    if (!s.courses.has(addedCourse.courseID)) {
      throw new Error(
        `Schedule.updateAfterAddAI: added course "${addedCourse.courseID}" is not in the schedule`,
      );
    }
    return await this.suggestCourseAI(owner);
  }

  private ensureState(owner: User) {
    let state = this.schedules.get(owner.id);
    if (!state) {
      state = { courses: new Map<string, Course>() };
      this.schedules.set(owner.id, state);
    }
    return state;
  }
}

```
