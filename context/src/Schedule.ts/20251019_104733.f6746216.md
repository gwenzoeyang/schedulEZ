---
timestamp: 'Sun Oct 19 2025 10:47:33 GMT-0400 (Eastern Daylight Time)'
content_id: f674621674b66b1db5c2894fb2dfbd99112847607c9148ad563f45fcb9d442d3
---

# file: src/Schedule.ts

```typescript
// src/concepts/Schedule.ts

/**
 * === Lightweight domain stubs (swap for your real types) =====================
 */

import type { Course, TimeSlot } from "./CourseCatalog.ts";

export interface User {
  id: string;
  name?: string;
}

/**
 * === External dependencies (assumed implemented elsewhere) ===================
 */
export interface CourseCatalogLike {
  getById(courseID: string): Course; // throws if not found
  search(query?: string, filters?: unknown): Set<Course>; // used broadly to get candidates
}

export interface TravelViolation {
  code: string;
  message: string;
  details?: unknown;
}

export interface CrossRegTravelLike {
  violations(owner: User, courses: Course[]): TravelViolation[];
}

/** Simple AI chooser that picks ONE course from filtered candidates. */
export interface AIRecommenderLike {
  chooseCourse(
    owner: User,
    candidates: Course[],
    prefs: AIPreferences,
  ): Promise<Course | null> | Course | null;
}

/**
 * === New AI state container ===================================================
 */
export interface AIPreferences {
  major: string;
  interests: Set<string>;
  availability: Set<TimeSlot>;
}

/**
 * === Schedule concept (AI-augmented) =========================================
 * purpose:
 *   let a student compose a tentative plan while preventing time conflicts.
 *   optionally, use AI to recommend new courses that fit the student’s major,
 *   interests, and available time slots, refreshing the suggestion when a
 *   recommended course is added.
 *
 * principle:
 *   each schedule belongs to one student.
 *   adding a course must check for overlapping times and infeasible travel gaps.
 *   the AI recommendation feature is optional and reads from the CourseCatalog
 *   and the student’s preferences. If AI is disabled/unused, behavior stays the same.
 *
 * state:
 *   userId -> {
 *     courses: Map<courseID, Course>
 *     aiPreferences?: AIPreferences
 *     aiSuggestion?: Course
 *   }
 */
export class Schedule {
  private schedules: Map<
    string,
    {
      courses: Map<string, Course>;
      aiPreferences?: AIPreferences;
      aiSuggestion?: Course;
    }
  > = new Map();

  constructor(
    private readonly catalog: CourseCatalogLike,
    private readonly travel: CrossRegTravelLike,
    private readonly ai: AIRecommenderLike,
  ) {}

  // ------------------------------ core actions -------------------------------

  addCourse(owner: User, course: Course): void {
    // Existence in CourseCatalog (authoritative)
    this.catalog.getById(course.courseID);

    const s = this.ensureState(owner);

    // Prevent duplicates
    if (s.courses.has(course.courseID)) {
      throw new Error(
        `Schedule.addCourse: course "${course.courseID}" is already in the schedule`,
      );
    }

    // Check time overlaps
    for (const existing of s.courses.values()) {
      if (coursesOverlap(existing, course)) {
        throw new Error(
          `Schedule.addCourse: "${course.courseID}" overlaps with "${existing.courseID}"`,
        );
      }
    }

    // Check cross-reg travel feasibility
    const union = [...s.courses.values(), course];
    const vios = this.travel.violations(owner, union);
    if (vios.length > 0) {
      const msg = vios.map((v) => v.message).join("; ");
      throw new Error(
        `Schedule.addCourse: travel/transition infeasible — ${msg}`,
      );
    }

    // Commit
    s.courses.set(course.courseID, course);
  }

  removeCourse(owner: User, courseID: string): void {
    const s = this.ensureState(owner);
    if (!s.courses.has(courseID)) {
      throw new Error(
        `Schedule.removeCourse: course "${courseID}" not found in schedule`,
      );
    }
    s.courses.delete(courseID);
  }

  listSchedule(owner: User): Set<Course> {
    const s = this.ensureState(owner);
    if (s.courses.size === 0) {
      throw new Error(`Schedule.listSchedule: schedule is empty`);
    }
    return new Set(s.courses.values());
  }

  clear(owner: User): void {
    const s = this.ensureState(owner);
    s.courses.clear();
  }

  // ------------------------------ AI actions ---------------------------------

  /**
   * setAIPreferences(owner, major, interests, availability)
   * effects: create or update aiPreferences for the owner
   */
  setAIPreferences(
    owner: User,
    major: string,
    interests: Set<string>,
    availability: Set<TimeSlot>,
  ): void {
    const s = this.ensureState(owner);
    s.aiPreferences = { major, interests, availability };
    // Optional: clear stale suggestion on major/interests/availability change
    s.aiSuggestion = undefined;
  }

  /**
   * suggestCourseAI(owner) -> Course
   * requires: CourseCatalog available; aiPreferences defined
   * effects:
   *   - filter CourseCatalog for courses that do not conflict with the owner’s
   *     schedule or availability
   *   - call an LLM to select one course matching the owner’s major & interests
   *   - store and return that course as aiSuggestion
   */
  async suggestCourseAI(owner: User): Promise<Course> {
    const s = this.ensureState(owner);
    if (!s.aiPreferences) {
      throw new Error(
        `Schedule.suggestCourseAI: aiPreferences not set for this user`,
      );
    }

    // Broad candidate pool (you can add filters at the CourseCatalog layer too)
    const all = [...(this.catalog.search() ?? new Set<Course>())];

    // Filter 1: drop courses already in schedule
    const notInSchedule = all.filter((c) => !s.courses.has(c.courseID));

    // Filter 2: time conflict check against schedule
    const noTimeConflicts = notInSchedule.filter(
      (cand) => ![...s.courses.values()].some((ex) => coursesOverlap(ex, cand)),
    );

    // Filter 3: availability fit (every meeting time fits within at least one availability slot)
    const fitsAvail = noTimeConflicts.filter((cand) =>
      fitsAvailability(cand, s.aiPreferences!.availability)
    );

    // Filter 4: travel feasibility (no violations when tentatively adding candidate)
    const travelOK = fitsAvail.filter((cand) => {
      const union = [...s.courses.values(), cand];
      return this.travel.violations(owner, union).length === 0;
    });

    // Let the AI pick ONE from final candidates
    const pick =
      (await this.ai.chooseCourse(owner, travelOK, s.aiPreferences)) ?? null;

    if (!pick) {
      throw new Error(
        `Schedule.suggestCourseAI: no suitable course found by AI`,
      );
    }

    s.aiSuggestion = pick;
    return pick;
  }

  /**
   * updateAfterAddAI(owner, addedCourse) -> Course
   * requires: addedCourse exists in owner’s schedule and aiPreferences defined
   * effects:
   *   - update availability by removing addedCourse’s meetingTimes
   *   - call the LLM again to find a new course that fits updated availability & interests
   *   - store and return the new aiSuggestion
   */
  async updateAfterAddAI(owner: User, addedCourse: Course): Promise<Course> {
    const s = this.ensureState(owner);

    if (!s.aiPreferences) {
      throw new Error(
        `Schedule.updateAfterAddAI: aiPreferences not set for this user`,
      );
    }
    if (!s.courses.has(addedCourse.courseID)) {
      throw new Error(
        `Schedule.updateAfterAddAI: added course "${addedCourse.courseID}" is not in the schedule`,
      );
    }

    // 1) Update availability (remove the time blocks occupied by addedCourse)
    s.aiPreferences = {
      ...s.aiPreferences,
      availability: subtractTimeslots(
        s.aiPreferences.availability,
        new Set(addedCourse.meetingTimes ?? []),
      ),
    };

    // 2) Refresh suggestion with the new availability
    const next = await this.suggestCourseAI(owner);
    return next;
  }

  // ------------------------------ internals ----------------------------------

  private ensureState(owner: User) {
    let state = this.schedules.get(owner.id);
    if (!state) {
      state = { courses: new Map<string, Course>() };
      this.schedules.set(owner.id, state);
    }
    return state;
  }
}

/** ============================== Helpers ================================== */

function coursesOverlap(a: Course, b: Course): boolean {
  for (const ta of a.meetingTimes ?? []) {
    for (const tb of b.meetingTimes ?? []) {
      if (ta.day !== tb.day) continue;
      if (
        intervalsOverlap(
          toMinutes(ta.start),
          toMinutes(ta.end),
          toMinutes(tb.start),
          toMinutes(tb.end),
        )
      ) {
        return true;
      }
    }
  }
  return false;
}

function intervalsOverlap(
  aStart: number,
  aEnd: number,
  bStart: number,
  bEnd: number,
): boolean {
  // Strict overlap; edge-touching is allowed (aEnd == bStart is OK)
  return aStart < bEnd && bStart < aEnd;
}

function toMinutes(hhmm: string): number {
  const [h, m] = hhmm.split(":").map(Number);
  return h * 60 + m;
}

/**
 * A course "fits" availability if every meeting time is fully contained in
 * at least one availability slot on the same day.
 */
function fitsAvailability(
  course: Course,
  availability: Set<TimeSlot>,
): boolean {
  const avail = [...availability];
  return (course.meetingTimes ?? []).every((mt) =>
    avail.some((av) => av.day === mt.day && contains(av, mt))
  );
}

function contains(outer: TimeSlot, inner: TimeSlot): boolean {
  return toMinutes(outer.start) <= toMinutes(inner.start) &&
    toMinutes(outer.end) >= toMinutes(inner.end);
}

/**
 * Remove a set of occupied TimeSlots from availability (day-wise subtraction).
 * Simplified: drop any availability slots that are fully covered by occupied
 * slots, and shrink partially overlapping ones (split into at most two).
 */
function subtractTimeslots(
  availability: Set<TimeSlot>,
  occupied: Set<TimeSlot>,
): Set<TimeSlot> {
  let result: TimeSlot[] = [...availability];

  for (const occ of occupied) {
    const out: TimeSlot[] = [];
    const oS = toMinutes(occ.start);
    const oE = toMinutes(occ.end);

    for (const av of result) {
      if (av.day !== occ.day) {
        out.push(av);
        continue;
      }
      const aS = toMinutes(av.start);
      const aE = toMinutes(av.end);

      // no overlap
      if (oE <= aS || oS >= aE) {
        out.push(av);
        continue;
      }

      // occ fully covers av -> remove av
      if (oS <= aS && oE >= aE) {
        // drop
        continue;
      }

      // partial overlaps -> split
      if (oS > aS) {
        out.push({ ...av, end: minutesToHHMM(oS) });
      }
      if (oE < aE) {
        out.push({ ...av, start: minutesToHHMM(oE) });
      }
    }

    result = out;
  }

  return new Set(result);
}

function minutesToHHMM(mins: number): string {
  const h = Math.floor(mins / 60);
  const m = mins % 60;
  const hh = String(h).padStart(2, "0");
  const mm = String(m).padStart(2, "0");
  return `${hh}:${mm}`;
}

```
